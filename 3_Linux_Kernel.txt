Linux kernel integration
===============================================================================The next task to solve after system bus integration is OS integration. Linux based operating systems were chosen as the most robust and widespread operating systems with strong community support. The device will be automatically integrated in sysfs. Sysfs is a virtual file system provided by the Linux kernel. By using virtual files, sysfs exports information about various kernel subsystems, hardware devices and associated device drivers from the kernel's device model to user space. In addition to providing information about various devices and kernel subsystems, exported virtual files are also used for their configuring. User model of the device contains n + 1 files, each of n files corresponds one input and one cprresponds output. They are named in following manner in1, in2, in3,...inn, res. Each "in" file is write only and the "res" is read only. Computation launches after last input (inn) written. All the files are located /sys/kernel/mm/devicename. Where "devicename" is node with name of compositional hardware device. Consider kernel API used to create this device driver. Firstly called accel_kobj = kobject_create_and_add ("accelerator", mm_kobj), where mm_kobj is node /sys/kernel/mm, which is defined in kernel headers, and "accelerator" is "devicename", discussed previously. As the result new kobject node returned. With call sysfs_create_group(accel_kobj, &attr_group) all files to node accel_obj were added. attr_group is entity of struct attribute_group. The attribute group interface is a simplified interface for easily adding and removing a set of attributes with a single call. An attribute group is simply an array of attributes to be added to an object, as represented by the attrs field. "Attribute" means leaf (file) in sysfs filesystem. Field attrs of struct attribute_group contains NULL terminated array of struct kobj_attribute, which contains name of attribute, read/write permissions and pointers to read/write functions for each attribute. Permissions are set to 0666, that everyone on the system could exploit the hardware. All attributes applied with kobject_put(accel_kobj).
The other thing to discuss is memory mapping of device. ioremap() function is used to map physical memory to kernel memory space. In order to unmap memory used iounmap().